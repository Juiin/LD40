<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-50</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>room_width = 1;
room_height = 1;
grid_width = scr_gen(global.area,"grid_width");
grid_height = scr_gen(global.area,"grid_height");

/*
room_width = (CELL_WIDTH/16) * 720 *4
room_height = (CELL_HEIGHT/16) * 720*4

grid_width = room_width div CELL_WIDTH
grid_height  = room_height div CELL_HEIGHT
*/

newpath = noone

randomize();

floor_tiles = 0;
max_floor_tiles = scr_gen(global.area,"max_floor_tiles");; //how "big" the dungeon will be


grid = ds_grid_create(grid_width,grid_height);

ds_grid_set_region(grid,0,0,grid_width-1,grid_height-1,VOID);

//Create Controller in the middle of the grid
c = ds_list_create();
ds_list_add(c,ds_map_create())

ds_map_add(c[| 0],"cx",grid_width div 2);
ds_map_add(c[| 0],"cy",grid_height div 2);
ds_map_add(c[| 0],"cdir", choose(0,90,180,270));

//contoller move odds from 0-1 0%-100%
odds = 1;

do
{
    
    controller_amount = ds_list_size(c);
    for(var i=0;i&lt;controller_amount;i++)
    {
        cdir = ds_map_find_value(c[| i],"cdir");
        cx = ds_map_find_value(c[| i],"cx");
        cy = ds_map_find_value(c[| i],"cy");  
    
    
        //Place floor tile at controller position
        /*
        if(grid[# ds_map_find_value(c[| i], "cx"),ds_map_find_value(c[| i],"cy")] != FLOOR)
        {
            //grid[# ds_map_find_value(c[| i],"cx"),ds_map_find_value(c[| i],"cy")] = FLOOR;
            ds_grid_set_region(grid,cx,cy,cx,cy,FLOOR);
            floor_tiles++;
        }
        */
        //set room sizes
        if(scr_chance(scr_gen(global.area,"5x5_chance")))
        {
            roomw = 4;
            roomh = 4;
        }
        else if(scr_chance(scr_gen(global.area,"4x4_chance")))
        {
            roomw = 3;
            roomh = 3;            
        }
        else if(scr_chance(scr_gen(global.area,"3x3_chance")))
        {
            roomw = 2;
            roomh = 2; 
        }
        else if(scr_chance(scr_gen(global.area,"2x2_chance")))
        {
            roomw = 1;
            roomh = 1; 
        }
        else
        {
            roomw = 0;
            roomh = 0; 
        }
        
        
        /*
        if(random(1) &lt; 0.99)
        {
            roomw = irandom_range(0,0);
            roomh = irandom_range(0,0);
        }
        else 
        {
            roomw = irandom_range(3,5);
            roomh = irandom_range(3,5);
        }
        */
        
        pre_ft = scr_floor_tile_amount_region();
        switch(cdir)
        {
            case 0:
            ds_grid_set_region(grid,cx,cy-ceil(roomh),cx+roomw,cy+floor(roomh),FLOOR);
            break;
            case 90:
            ds_grid_set_region(grid,cx-ceil(roomw),cy,cx+floor(roomw),cy-roomh,FLOOR);
            break;
            case 180:
            ds_grid_set_region(grid,cx,cy-ceil(roomh),cx-roomw,cy+floor(roomh),FLOOR);
            break;
            case 270:
            ds_grid_set_region(grid,cx-ceil(roomw),cy,cx+floor(roomw),cy+roomh,FLOOR);
            break;
        }
        post_ft = scr_floor_tile_amount_region();
        floor_tiles+=(post_ft-pre_ft)
        
        if(scr_chance(scr_gen(global.area,"180_turn")))
        {
            ds_map_replace(c[| i],"cdir", (cdir+180+360) mod 360)
        }
        else if(scr_chance(scr_gen(global.area,"-90_turn")))
        {
            ds_map_replace(c[| i],"cdir", (cdir-90+360) mod 360)
        }
        else if(scr_chance(scr_gen(global.area,"+90_turn")))
        {
            ds_map_replace(c[| i],"cdir", (cdir+90+360) mod 360)
        }

              
        /*
        //change direction
        if(random(1) &lt; odds)
        {
            ds_map_replace(c[| i],"cdir", (choose(cdir,cdir,cdir,cdir,cdir,cdir,cdir-90,cdir-90,cdir+90,cdir+90,cdir+180)+360) mod 360)
        }   
        */
        
        //Move the controller
        ds_map_replace(c[| i],"cx",ds_map_find_value(c[| i],"cx")+lengthdir_x(1,ds_map_find_value(c[| i],"cdir")))
        ds_map_replace(c[| i],"cy",ds_map_find_value(c[| i],"cy")+lengthdir_y(1,ds_map_find_value(c[| i],"cdir")))
        
        ds_map_replace(c[| i],"cx",clamp(ds_map_find_value(c[| i],"cx"),6,grid_width-7))
        ds_map_replace(c[| i],"cy",clamp(ds_map_find_value(c[| i],"cy"),6,grid_width-7))
        
       
        //spawn a new one
        if(random(1) &lt; scr_gen(global.area,"c_spawn_base")-(scr_gen(global.area,"c_spawn_decrease")*(ds_list_size(c)-1)))
        {
            ds_list_add(c,ds_map_create())
            ds_map_add(c[| ds_list_size(c)-1],"cx",ds_map_find_value(c[| i],"cx"));
            ds_map_add(c[| ds_list_size(c)-1],"cy",ds_map_find_value(c[| i],"cy"));
            ds_map_add(c[| ds_list_size(c)-1],"cdir", choose(0,90,180,270));
            ds_map_add(c[| ds_list_size(c)-1],"destroy", false);
        }
        
        //destroy current controller by chance
        if(controller_amount &gt; 1 &amp;&amp; random(1) &lt; scr_gen(global.area,"c_destroy_base")+((controller_amount-1)*scr_gen(global.area,"c_destroy_increase")))
        {
            ds_map_destroy(c[| i]);
            ds_list_delete(c,i);
            break;
        } 
    }
}
until(floor_tiles &gt;= max_floor_tiles)

//Clean up
for(var i=1;i&lt;grid_width-1;i++)
{
    for(var j=1;j&lt;grid_height-1;j++)
    {
        if(grid[# i, j] == VOID)
        {
            /*if(grid[# i+1, j] == FLOOR &amp;&amp; grid[# i-1,j] == FLOOR &amp;&amp; grid[# i,j+1] == FLOOR &amp;&amp; grid[# i,j-1] == FLOOR)
            {
                grid[# i,j] = FLOOR;   
            }*/        
            if(grid[# i,j+1] == FLOOR &amp;&amp; grid[# i,j-1] == FLOOR) grid[# i,j] = FLOOR;
        }
    }
}


//Place Walls
for(var i=1;i&lt;grid_width-1;i++)
{
    for(var j=1;j&lt;grid_height-1;j++)
    {
        if(grid[# i,j] == FLOOR)
        {
            if(grid[# i+1,j] != FLOOR) grid[# i+1,j] = WALL;
            if(grid[# i-1,j] != FLOOR) grid[# i-1,j] = WALL;
            if(grid[# i,j+1] != FLOOR) grid[# i,j+1] = WALL;
            if(grid[# i,j-1] != FLOOR) grid[# i,j-1] = WALL;
        }
    }
}

//Draw the Level
for(var i=1;i&lt;grid_width-1;i++)
{
    for(var j=1;j&lt;grid_height-1;j++)
    {
        if(grid[# i,j] == FLOOR)
        {
            tile_add(scr_gen(global.area,"floor_tile_01"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
           /* for(var e=0;e&lt;2;e++)
            {
                for(var r=0;r&lt;2;r++)
                {
                    tile_add(bg_floor,0,0,CELL_WIDTH,CELL_HEIGHT,i*64+(e*CELL_WIDTH),j*64+(r*CELL_HEIGHT),0)
                }
           }*/
        }
        else if(grid[# i,j] == WALL)
        {
            if(grid[#i,j+1] == FLOOR &amp;&amp; (grid[#i,j-1] == WALL || grid[#i,j-1] == VOID)) tile_add(scr_gen(global.area,"wall_tile_02"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
            else
            {
                tile_add(scr_gen(global.area,"wall_tile_01"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
                if(grid[#i+1,j] == FLOOR) tile_add(scr_gen(global.area,"right_border_tile"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
                if(grid[#i,j-1] == FLOOR) tile_add(scr_gen(global.area,"top_border_tile"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
                if(grid[#i-1,j] == FLOOR) tile_add(scr_gen(global.area,"left_border_tile"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
                
                //corners
                if(grid[#i+1,j+1] == FLOOR &amp;&amp; grid[#i+1,j] == WALL) tile_add(scr_gen(global.area,"right_border_tile"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
                if(grid[#i-1,j+1] == FLOOR &amp;&amp; grid[#i-1,j] == WALL) tile_add(scr_gen(global.area,"left_border_tile"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
                    
                if(grid[#i+1,j-1] == FLOOR &amp;&amp; grid[#i+1,j] == WALL &amp;&amp; (grid[# i,j-1] == WALL || grid[# i,j-1] == VOID)) tile_add(scr_gen(global.area,"tr_corner_tile"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
                if(grid[#i-1,j-1] == FLOOR &amp;&amp; grid[#i-1,j] == WALL &amp;&amp; (grid[# i,j-1] == WALL || grid[# i,j-1] == VOID)) tile_add(scr_gen(global.area,"tl_corner_tile"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
            }
            instance_create(i*CELL_WIDTH,j*CELL_HEIGHT,obj_wall);
        }
        else if(grid[# i,j] == VOID)
        {
            tile_add(scr_gen(global.area,"void_tile_01"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);  
            if(grid[#i+1,j] == FLOOR) tile_add(scr_gen(global.area,"right_border_tile"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
            if(grid[#i,j-1] == FLOOR) tile_add(scr_gen(global.area,"top_border_tile"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
            if(grid[#i-1,j] == FLOOR) tile_add(scr_gen(global.area,"left_border_tile"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0); 
            instance_create(i*CELL_WIDTH,j*CELL_HEIGHT,obj_wall);
            
            //corners
            if(grid[#i+1,j+1] == FLOOR &amp;&amp; grid[#i+1,j] == WALL) tile_add(scr_gen(global.area,"right_border_tile"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
            if(grid[#i-1,j+1] == FLOOR &amp;&amp; grid[#i-1,j] == WALL) tile_add(scr_gen(global.area,"left_border_tile"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
            
            if(grid[#i+1,j-1] == FLOOR &amp;&amp; grid[#i+1,j] == WALL &amp;&amp; (grid[# i,j-1] == WALL || grid[# i,j-1] == VOID)) tile_add(scr_gen(global.area,"tr_corner_tile"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
            if(grid[#i-1,j-1] == FLOOR &amp;&amp; grid[#i-1,j] == WALL &amp;&amp; (grid[# i,j-1] == WALL || grid[# i,j-1] == VOID)) tile_add(scr_gen(global.area,"tl_corner_tile"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
        }
        else if (grid[# i,j] == EXIT)
        {
            tile_add(scr_gen(global.area,"exit_tile_01"),0,0,CELL_WIDTH,CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,0);
        }
    }
}

//Determine Player Spawn
max_len = 0
player_x = 0
player_y = 0            
mp_grid = mp_grid_create(0,0,grid_width,grid_height,CELL_WIDTH,CELL_HEIGHT);
mp_grid_add_instances(mp_grid,obj_wall,true)
path = path_add();
path_set_kind(path,1);
path_set_precision(path,8);
for(var i=1;i&lt;grid_width-1;i++)
{
    for(var j=1;j&lt;grid_height-1;j++)
    {
        if(grid[# i,j] == FLOOR)
        {
            if(mp_grid_path(mp_grid,path,(grid_width/2)*CELL_WIDTH,(grid_height/2)*CELL_HEIGHT,i*CELL_WIDTH,j*CELL_HEIGHT,true))
            {
                len = path_get_length(path);
                if(len &gt; max_len)
                {
                    max_len = len;
                    player_x = i;
                    player_y = j;
                }
            } 
        }
    }
}
//Create Player
//scr_create_player(player_x*CELL_WIDTH+16,player_y*CELL_HEIGHT+16);
if(instance_exists(obj_player_parent))
{
    obj_player_parent.x = player_x*CELL_WIDTH+24;
    obj_player_parent.y = player_y*CELL_HEIGHT+24;
}


//Determine EXIT
max_len = 0
exit_x = 0
exit_y = 0
for(var i=1;i&lt;grid_width-1;i++)
{
    for(var j=1;j&lt;grid_height-1;j++)
    {
        if(grid[# i,j] == FLOOR)
        {
            
            if(mp_grid_path(mp_grid,path,obj_player_parent.x,obj_player_parent.y,i*CELL_WIDTH,j*CELL_HEIGHT,true))
            {
                len = path_get_length(path);
                if(len &gt; max_len)
                {
                    max_len = len;
                    exit_x = i;
                    exit_y = j;
                    if(path_exists(newpath)) path_delete(newpath);
                    newpath = path_duplicate(path)
                }
            }  
        }
    }
}
//Create Exit
grid[# exit_x,exit_y] = EXIT;
tile_add(bg_exit,0,0,CELL_WIDTH,CELL_HEIGHT,exit_x*CELL_WIDTH,exit_y*CELL_HEIGHT,0);
var inst = instance_create(exit_x*CELL_WIDTH,exit_y*CELL_HEIGHT,obj_warp);
inst.destination = rm_overworld;

//Spawn Enemies
for(var i=1;i&lt;grid_width-1;i++)
{
    for(var j=1;j&lt;grid_height-1;j++)
    {
        if(grid[# i,j] == FLOOR)
        {
            if (mp_grid_path(mp_grid,path,obj_player_parent.x,obj_player_parent.y,i*CELL_WIDTH,j*CELL_WIDTH,true))
            {  
            
                len = path_get_length(path);
                if (len &gt; 400)
                {
                    if(random(1) &lt; 0.1)
                    {
                        instance_create(i*CELL_WIDTH+24,j*CELL_HEIGHT+24,choose(obj_enemy_caster,obj_enemy_charger,obj_enemy_melee_1));
                    }
                    
                }
                 
            }
              
        }
    }
}
//Spawn Deco
//Torches
for(var i=1;i&lt;grid_width-1;i++)
{
    for(var j=1;j&lt;grid_height-1;j++)
    {
        if(grid[# i ,j] == WALL)
        {
            if(grid[# i,j+1] == FLOOR &amp;&amp; scr_chance(0.5))
            {
                instance_create(i*CELL_WIDTH+(CELL_WIDTH/2) ,j*CELL_HEIGHT+(CELL_HEIGHT/2),obj_torch); 
            }
        }    
    }
}
//Grass
/*
for(var i=1;i&lt;grid_width-1;i++)
{
    for(var j=1;j&lt;grid_heigh-1t;j++)
    {
        if(grid[# i ,j] == FLOOR)
        {
            if(scr_chance(0.1))
            {
                var xoff = 0;
                for(var k=0;k&lt;5;k++)
                {
                    var xscale = random_range(0.5,1);
                    var inst = instance_create(i*CELL_WIDTH+xoff,j*CELL_HEIGHT+CELL_HEIGHT,obj_grass);
                    inst.image_xscale = xscale;
                    xoff+=xscale*sprite_get_width(spr_grass);
                }
            }
        }    
    }
}
*/
//Stones
for(var i=1;i&lt;grid_width-1;i++)
{
    for(var j=1;j&lt;grid_height-1;j++)
    {
        if(grid[# i ,j] == FLOOR)
        {
            if(scr_chance(0.5))
            {
                var inst = instance_create(i*CELL_WIDTH,j*CELL_HEIGHT,obj_stone);
                inst.image_blend = scr_gen(global.area,"rock_blend");
                
                inst.x = irandom_range(inst.x+(sprite_get_width(inst.sprite_index)),inst.x+CELL_WIDTH-(sprite_get_width(inst.sprite_index)));
                inst.y = irandom_range(inst.y+(sprite_get_height(inst.sprite_index)),inst.y+CELL_HEIGHT-(sprite_get_height(inst.sprite_index)));    
                
            }
        }    
    }
}
//Vases 
for(var i=1;i&lt;grid_width-1;i++)
{
    for(var j=1;j&lt;grid_height-1;j++)
    {
        if(grid[# i ,j] == FLOOR)
        {
            if(scr_nearby_value(grid,i,j,WALL))
            {
                if(scr_chance(0.5))
                {
                    //We want to spawn vases here, need to figure out where exactly
                    
                    //Add all possible Nearby Walls to list
                    var wall_list = ds_list_create();
                    if(grid[# i-1,j] == WALL) ds_list_add(wall_list,"Left");
                    if(grid[# i+1,j] == WALL) ds_list_add(wall_list,"Right");
                    if(grid[# i,j-1] == WALL) ds_list_add(wall_list,"Up");
                    if(grid[# i,j+1] == WALL) ds_list_add(wall_list,"Down");
                    
                    //Randomize List
                    ds_list_shuffle(wall_list);
                    
                    var vase_amount,start_x,start_y,dir;
                    
                    //Set Variables based on where the wall is
                    switch(wall_list[| 0])
                    {
                        case "Left":
                        vase_amount = irandom_range(1,3);
                        start_x = i*CELL_WIDTH;
                        start_y = j*CELL_HEIGHT;
                        dir = "Down";
                        break;
                        case "Right":
                        vase_amount = irandom_range(1,3);
                        start_x = (i*CELL_WIDTH)+CELL_WIDTH-sprite_get_width(spr_vase);
                        start_y = j*CELL_HEIGHT;
                        dir = "Down";
                        break;
                        case "Up":
                        vase_amount = irandom_range(1,3);
                        start_x = i*CELL_WIDTH;
                        start_y = j*CELL_HEIGHT;
                        dir = "Right";
                        break;
                        case "Down":
                        vase_amount = irandom_range(1,3);
                        start_x = i*CELL_WIDTH;
                        start_y = (j*CELL_HEIGHT)+CELL_HEIGHT-sprite_get_height(spr_vase);
                        dir = "Right";
                        break;
                    }
                    
                    //Spawn Vases Near Walls
                    for(var k=0;k&lt;vase_amount;k++)
                    {
                         if(dir == "Down") down=k; else down=0;
                         if(dir == "Right") right=k; else right=0;
                         
                         var inst = instance_create(start_x+(right*sprite_get_width(spr_vase)),start_y+(down*sprite_get_height(spr_vase)),obj_vase); 
                         inst.image_blend = scr_gen(global.area,"vase_blend");
                    }
                    //Cleanup
                    ds_list_destroy(wall_list);
                }
            }
        }
    }
}
//destroy not needed ds
for(var i=0;i&lt;ds_list_size(c);i++)
{
    ds_map_destroy(c[| i])
}
ds_list_destroy(c);
path_delete(path);
mp_grid_destroy(mp_grid);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Destroy DS
ds_grid_destroy(grid);
 path_delete(newpath);
tile_layer_delete(0);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(global.debug)
{
    draw_set_colour(c_black)
    if(path_exists(newpath)) draw_path_all(newpath,0,0,true)
    draw_set_colour(c_white)
    
    draw_text(mouse_x,mouse_y,string(grid[#mouse_x div CELL_WIDTH, mouse_y div CELL_HEIGHT]))
}


/*

draw_text_transformed(80,10,scr_floor_tile_amount_all(),1,1,image_angle)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
